NFTs Bootcamp - 02
Solange Gueiros
NFT Brasil - Set/2024

https://pad.riseup.net/p/nftbrasil-03

Inscricoes no Hackathon
https://taikai.network/NFTBrasil/hackathons/hackathoNFBrasil/

Slides
https://docs.google.com/presentation/d/1SktvN7CX7IZVAgK7iT2M8Z5pJHngvIousgPewbU8G7A/pub?start=false&loop=false&delayms=3000

Aula 01
https://www.youtube.com/watch?v=KTOxNw65wBU

Aula 02
https://www.youtube.com/watch?v=FekcGFHMPK4

Aula 03
https://www.youtube.com/watch?v=XJ3FjuDLPAQ

Nome - Rede social (se quiser)
Sol - solangegueiros
MAIKAO - @maikao_official
Jeff Souza - instagram.com/j3ffsouza
Marina Wentzel - marinawentzel@gmail.com
Raphael - @raphaelrcarvalho
Alexandre Eduardo - @aleedu_avelino
JosÃ© Aldo Teixeira
Pedr0x - https://warpcast.com/pedr0x.eth


**********************************

https://remix.ethereum.org/
Icone 5 - DEPLOY & RUN TRANSACTIONS
ENVIRONMENT
Injected provider - Metamask
Check the Sepolia (11155111) network

Icone 2 - FILE EXPLORER
Criar o arquivo
CrossChainPriceNFT.sol

********************************* InÃ­cio do cÃ³digo *********************************
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// Deploy this contract on Sepolia

// Importing OpenZeppelin contracts
import "@openzeppelin/contracts@4.6.0/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts@4.6.0/utils/Counters.sol";
import "@openzeppelin/contracts@4.6.0/utils/Base64.sol";

// Importing Chainlink contracts
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract CrossChainPriceNFT is ERC721, ERC721URIStorage {
    using Counters for Counters.Counter;
    using Strings for uint256;

    Counters.Counter public tokenIdCounter;

    // Create price feed
    AggregatorV3Interface internal priceFeed;
    uint256 public lastPrice = 0;

    string priceIndicatorUp = unicode"ðŸ˜€";
    string priceIndicatorDown = unicode"ðŸ˜”";
    string priceIndicatorFlat = unicode"ðŸ˜‘";
    string public priceIndicator;

    struct ChainStruct {
        uint64 code;
        string name;
        string color;
    }
    mapping (uint256 => ChainStruct) chain;

    //https://docs.chain.link/ccip/supported-networks/testnet
    constructor() ERC721("CrossChain Price", "CCPrice") {
        chain[0] = ChainStruct ({
            code: 16015286601757825753,
            name: "Sepolia",
            color: "#0000ff" //blue
        });
        chain[1] = ChainStruct ({
            code: 14767482510784806043,
            name: "Fuji",
            color: "#ff0000" //red
        });
        chain[2] = ChainStruct ({
            code: 12532609583862916517,
            name: "Mumbai",
            color: "#4b006e" //purple
        });

        // https://docs.chain.link/data-feeds/price-feeds/addresses        
        priceFeed = AggregatorV3Interface(
            // Sepolia BTC/USD
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43            
        );

        // Mint an NFT
        mint(msg.sender);
    }

    function mint(address to) public {
        // Mint from Sepolia network = chain[0]
        mintFrom(to, 0);
    }

    function mintFrom(address to, uint256 sourceId) public {
        // sourceId 0 Sepolia, 1 Fuji, 2 Mumbai
        uint256 tokenId = tokenIdCounter.current();
        _safeMint(to, tokenId);
        updateMetaData(tokenId, sourceId);    
        tokenIdCounter.increment();
    }

    // Update MetaData
    function updateMetaData(uint256 tokenId, uint256 sourceId) public {
        // Create the SVG string
        string memory finalSVG = buildSVG(sourceId);
           
        // Base64 encode the SVG
        string memory json = Base64.encode(
            bytes(
                string(
                    abi.encodePacked(
                        '{"name": "Cross-chain Price SVG",',
                        '"description": "SVG NFTs in different chains",',
                        '"image": "data:image/svg+xml;base64,',
                        Base64.encode(bytes(finalSVG)), '",',
                        '"attributes": [',
                            '{"trait_type": "source",',
                            '"value": "', chain[sourceId].name ,'"},',
                            '{"trait_type": "price",',
                            '"value": "', lastPrice.toString() ,'"}',
                        ']}'
                    )
                )
            )
        );
        // Create token URI
        string memory finalTokenURI = string(
            abi.encodePacked("data:application/json;base64,", json)
        );
        // Set token URI
        _setTokenURI(tokenId, finalTokenURI);
    }

    // Build the SVG string
    function buildSVG(uint256 sourceId) internal returns (string memory) {

        // Create SVG rectangle with random color
        string memory headSVG = string(
            abi.encodePacked(
                "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:svgjs='http://svgjs.com/svgjs' width='500' height='500' preserveAspectRatio='none' viewBox='0 0 500 500'> <rect width='100%' height='100%' fill='",
                chain[sourceId].color,
                "' />"
            )
        );
        // Update emoji based on price
        string memory bodySVG = string(
            abi.encodePacked(
                "<text x='50%' y='50%' font-size='128' dominant-baseline='middle' text-anchor='middle'>",
                comparePrice(),
                "</text>"
            )
        );
        // Close SVG
        string memory tailSVG = "</svg>";

        // Concatenate SVG strings
        string memory _finalSVG = string(
            abi.encodePacked(headSVG, bodySVG, tailSVG)
        );
        return _finalSVG;
    }

    // Compare new price to previous price
    function comparePrice() public returns (string memory) {
        uint256 currentPrice = getChainlinkDataFeedLatestAnswer();
        if (currentPrice > lastPrice) {
            priceIndicator = priceIndicatorUp;
        } else if (currentPrice < lastPrice) {
            priceIndicator = priceIndicatorDown;
        } else {
            priceIndicator = priceIndicatorFlat;
        }
        lastPrice = currentPrice;
        return priceIndicator;
    }

    function getChainlinkDataFeedLatestAnswer() public view returns (uint256) {
        (, int256 price, , , ) = priceFeed.latestRoundData();
        return uint256(price);
    }

    function tokenURI(uint256 tokenId)
        public view override(ERC721, ERC721URIStorage) returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    // The following function is an override required by Solidity.
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage)
    {
        super._burn(tokenId);
    }
}
```
****************************** Fim do cÃ³digo *************************************************

#### Explicando o contrato CrossChainPriceNFT.sol

1. LicenÃ§a, Pragma e ComentÃ¡rio de Deploy:
- // SPDX-License-Identifier: MIT: Esta linha especifica a licenÃ§a MIT usada pelo contrato.
- pragma solidity 0.8.19;: Define a versÃ£o Solidity utilizada para compilar o contrato (versÃ£o 0.8.19).
- // Deploy this contract on Sepolia: Um comentÃ¡rio lembrando que o contrato deve ser implantado na rede de teste Sepolia.

2. ImportaÃ§Ãµes de Bibliotecas
- Estas linhas importam bibliotecas necessÃ¡rias para o funcionamento do contrato:
    - @openzeppelin/contracts/â€¦: Importa funcionalidades para tokens ERC721 (ERC721URIStorage) e utilitÃ¡rios como contador (Counters) e codificaÃ§Ã£o base64 (Base64).
    - @chainlink/contracts/â€¦: Importa interfaces para interagir com o serviÃ§o de orÃ¡culo de preÃ§os Chainlink (AggregatorV3Interface).

3. DefiniÃ§Ã£o do Contrato e Contador
- contract CrossChainPriceNFT is ERC721, ERC721URIStorage: Esta linha define o contrato CrossChainPriceNFT que herda funcionalidades de ambos os padrÃµes ERC721 (NFT bÃ¡sico) e ERC721URIStorage (permite armazenar a URI do token na blockchain).
- using Counters for Counters.Counter;: Habilita o uso de funÃ§Ãµes de contador para o tokenIdCounter.
- using Strings for uint256;: Permite converter valores inteiros em strings (necessÃ¡rio para criar JSON).

4. PreÃ§o do OrÃ¡culo e Emojis
- Counters.Counter public tokenIdCounter;: Declara um contador pÃºblico para atribuir IDs Ãºnicos a cada NFT cunhado.
- AggregatorV3Interface internal priceFeed;: Esta linha declara uma variÃ¡vel interna do tipo AggregatorV3Interface para interagir com o contrato Chainlink que fornece o preÃ§o do ativo.
- uint256 public lastPrice = 0;: Armazena o Ãºltimo preÃ§o obtido do feed de dados.
- TrÃªs variÃ¡veis string definem emojis indicadores para variaÃ§Ã£o de preÃ§o (priceIndicatorUp, priceIndicatorDown, e priceIndicatorFlat).

5. Estrutura ChainStruct e Construtor
- struct ChainStruct { ... }: Define uma estrutura nomeada ChainStruct para armazenar informaÃ§Ãµes sobre as blockchains suportadas:
    - uint64 code: CÃ³digo Ãºnico da blockchain.
    - string name: Nome da blockchain.
    - string color: Cor que representa a blockchain em formato HTML.
- O construtor constructor() executa as seguintes aÃ§Ãµes:
    - Inicializa o padrÃ£o ERC721 com um nome ("CrossChain Price") e sÃ­mbolo ("CCPrice").
    - Cria entradas no mapeamento chain para trÃªs redes de teste (Sepolia, Fuji, Mumbai) com seus cÃ³digos, nomes e cores.
    - Define a variÃ¡vel priceFeed para o endereÃ§o do feed de preÃ§o BTC/USD da rede Sepolia.
    - Cria automaticamente um NFT inicial para o deployer do contrato (usando mint(msg.sender)).

6. FunÃ§Ã£o mint
- function mint(address to) public { ... }: Esta funÃ§Ã£o pÃºblica permite cunhar um novo NFT para um determinado endereÃ§o (to).
- Internamente, ela chama mintFrom(to, 0) que assume a criaÃ§Ã£o do NFT na rede Sepolia (ID da rede 0).

7. FunÃ§Ã£o mintFrom
- function mintFrom(address to, uint256 sourceId) public { ... }: Esta funÃ§Ã£o pÃºblica permite cunhar um NFT especificando a ID da rede de origem (sourceId).
- Recupera a ID atual do token do contador.
- Cria um novo NFT com essa ID para o destinatÃ¡rio (to).
- Chama a funÃ§Ã£o updateMetaData para gerar e definir a URI inicial do token com base na rede de origem.
Incrementa o contador de ID do token.

8. FunÃ§Ã£o updateMetaData
- function updateMetaData(uint256 tokenId, uint256 sourceId) public { ... }: Esta funÃ§Ã£o pÃºblica atualiza os metadados de um NFT existente.
    - Chama a funÃ§Ã£o interna buildSVG para gerar uma string SVG representando o NFT.
    - Codifica a string SVG em base64 usando a biblioteca Base64.
    - Cria uma string JSON contendo os metadados do NFT, incluindo nome, descriÃ§Ã£o, imagem (SVG codificado) e atributos (rede de origem e preÃ§o).
    - Combina a string JSON com um prefixo para criar o URI final do token.
    - Define o URI final do token usando _setTokenURI.

9. FunÃ§Ã£o buildSVG
- function buildSVG(uint256 sourceId) internal returns (string memory) { ... }: Esta funÃ§Ã£o interna cria a string SVG que representa o NFT.
    - Gera o cÃ³digo SVG para um retÃ¢ngulo com a cor correspondente Ã  rede de origem.
    - Gera o cÃ³digo SVG para um texto que exibe o emoji indicando a variaÃ§Ã£o de preÃ§o.
    - Combina os cÃ³digos SVG do retÃ¢ngulo e do texto para criar o SVG final.

10. FunÃ§Ã£o comparePrice
- function comparePrice() public returns (string memory) { ... }: Esta funÃ§Ã£o pÃºblica compara o preÃ§o atual com o preÃ§o anterior e retorna o emoji correspondente.
    - ObtÃ©m o preÃ§o atual usando getChainlinkDataFeedLatestAnswer.
    - Compara o preÃ§o atual com o preÃ§o anterior e atualiza a variÃ¡vel priceIndicator com o emoji adequado.
    - Retorna o emoji indicando a variaÃ§Ã£o de preÃ§o.

11. FunÃ§Ã£o getChainlinkDataFeedLatestAnswer
- function getChainlinkDataFeedLatestAnswer() public view returns (uint256) { ... }: Esta funÃ§Ã£o pÃºblica obtÃ©m o Ãºltimo preÃ§o do feed de dados Chainlink.
    - Utiliza a funÃ§Ã£o latestRoundData do contrato AggregatorV3Interface para obter os dados da Ãºltima rodada.
    - Retorna o valor do preÃ§o como um uint256.

12. FunÃ§Ãµes tokenURI e _burn
- function tokenURI(uint256 tokenId) ...: Sobrescreve a funÃ§Ã£o tokenURI para retornar o URI do token.
- function _burn(uint256 tokenId) internal override ...: Sobrescreve a funÃ§Ã£o _burn para queimar um NFT.

----------------------------------------------------------------------------------------------------
Icone 5 - DEPLOY & RUN TRANSACTIONS
Deploy

Nome - CrossChainPriceNFT address
Sol - 0xa372c44DA07690E537e4fD0b8EA1b4b5ef50A956
MAIKAO - 0x097Ae1A53Dd12c056a1add95883E307ec23244d7
Jeff Souza - 0xeA6CB05A58214c45cCA9FB46666A89e681FdF922
Marina - 0xA90AaCB9F6C72139Cb29CbdD5e6C0bFDcdFc0ffF
Alexandre Eduardo - 0x59e595849D90c854638860ff93fC2099780ce491
Pedr0x - 0xD49CA935B6F7805bE5f3c8F04466526E0855E7C5
Raphael - 0x11429313030122cA0D00E54e926100845dF454b9



************************************
https://data.chain.link/
https://docs.chain.link/data-feeds/price-feeds/addresses

https://docs.chain.link/ccip/supported-networks/testnet

https://testnets.opensea.io/

Nome - Link da coleÃ§Ã£o
Sol - https://testnets.opensea.io/collection/crosschain-price-1705
Jeff Souza - https://testnets.opensea.io/collection/crosschain-price-1702
Pedr0x - https://testnets.opensea.io/collection/crosschain-price-1707
Alexandre - https://testnets.opensea.io/collection/crosschain-price-1706
Raphael - https://testnets.opensea.io/collection/crosschain-price-1708
JosÃ© Aldo - https://testnets.opensea.io/collection/crosschain-price-1709



*****************************

No Remix
Mint - para sua carteira

Price
56103.42413254
56177.00000000


Criar
CrossDestinationMinter.sol

********************************* InÃ­cio do cÃ³digo *********************************
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// Deploy this contract on Sepolia

import {CCIPReceiver} from "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol";
import {Client} from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";

interface InftMinter {
    function mintFrom(address account, uint256 sourceId) external;
}

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */
contract CrossDestinationMinter is CCIPReceiver {
    InftMinter public nft;

    event MintCallSuccessfull();
    // https://docs.chain.link/ccip/supported-networks/testnet
    address routerSepolia = 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59;

    constructor(address nftAddress) CCIPReceiver(routerSepolia) {
        nft = InftMinter(nftAddress);
    }

    function _ccipReceive(
        Client.Any2EVMMessage memory message
    ) internal override {
        (bool success, ) = address(nft).call(message.data);
        require(success);
        emit MintCallSuccessfull();
    }

    function testMint() external {
        // Mint from Sepolia
        nft.mintFrom(msg.sender, 0);
    }

    function testMessage() external {
        // Mint from Sepolia
        bytes memory message;
        message = abi.encodeWithSignature("mintFrom(address,uint256)", msg.sender, 0);

        (bool success, ) = address(nft).call(message);
        require(success);
        emit MintCallSuccessfull();
    }

    function updateNFT(address nftAddress) external {
        nft = InftMinter(nftAddress);
    }
}
```
********************************* Fim do cÃ³digo *********************************

#### Explicando o contrato CrossChainPriceNFT.sol

1. LicenÃ§a e Pragma
- // SPDX-License-Identifier: MIT: Define a licenÃ§a MIT usada pelo contrato.
- pragma solidity 0.8.19;: Especifica a versÃ£o Solidity utilizada para compilar o contrato (versÃ£o 0.8.19).

2. ImportaÃ§Ãµes
- import {CCIPReceiver} from "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol";: Importa a funcionalidade CCIPReceiver da biblioteca Chainlink CCIP para receber mensagens entre blockchains.
- import {Client} from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";: Importa a biblioteca Client da Chainlink CCIP para lidar com mensagens de forma mais genÃ©rica (nÃ£o utilizada diretamente neste contrato).

3. Interface InftMinter
- Define uma interface InftMinter com a funÃ§Ã£o mintFrom para abstrair a interaÃ§Ã£o com o contrato de cunhagem de NFTs. Essa interface permite que qualquer contrato que implemente a funÃ§Ã£o mintFrom seja utilizado pelo CrossDestinationMinter.

4. Contrato CrossDestinationMinter
- contract CrossDestinationMinter is CCIPReceiver**: Define o contrato CrossDestinationMinter que herda a funcionalidade CCIPReceiver para receber mensagens entre blockchains.

5. VariÃ¡vel nft
- InftMinter public nft;: Declara uma variÃ¡vel pÃºblica do tipo InftMinter para armazenar o endereÃ§o do contrato de cunhagem de NFT.

6. Evento MintCallSuccessfull
- event MintCallSuccessfull();: Define um evento para registrar quando uma chamada de cunhagem de NFT Ã© bem-sucedida.

7. EndereÃ§o do Roteador Sepolia
- // https://docs.chain.link/ccip/supported-networks/testnet: ComentÃ¡rio com um link para a documentaÃ§Ã£o sobre redes suportadas pelo CCIP (aqui indicando a rede de teste Sepolia).
- address routerSepolia = 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59;: Define o endereÃ§o do Roteador CCIP para a rede Sepolia (usado para validaÃ§Ã£o de mensagens).

8. Construtor (constructor)
- constructor(address nftAddress) CCIPReceiver(routerSepolia) { ... }: O construtor recebe o endereÃ§o do contrato de cunhagem de NFT como argumento e:
    - Chama o construtor da classe base CCIPReceiver passando o endereÃ§o do roteador Sepolia.
    - Inicializa a variÃ¡vel nft com o endereÃ§o do contrato de cunhagem de NFT fornecido.

9. FunÃ§Ã£o _ccipReceive
- function _ccipReceive(Client.Any2EVMMessage memory message) internal override { ... }: Esta funÃ§Ã£o interna sobreescreve a funÃ§Ã£o herdada _ccipReceive.
    - Ela Ã© chamada automaticamente quando o contrato recebe uma mensagem CCIP.
    - A funÃ§Ã£o verifica se a mensagem foi bem-sucedida e, em seguida, tenta executar os dados da mensagem (message.data) como uma chamada de funÃ§Ã£o no contrato de cunhagem de NFT (address(nft))
    - Se a chamada for bem-sucedida, o evento MintCallSuccessfull Ã© emitido.

10. FunÃ§Ã£o testMint
- function testMint() external { ... }: Esta funÃ§Ã£o pÃºblica simula uma chamada de cunhagem de NFT na rede Sepolia.
    - Ela chama diretamente a funÃ§Ã£o mintFrom do contrato de cunhagem de NFT, passando o endereÃ§o do remetente da transaÃ§Ã£o (msg.sender) e o ID da rede Sepolia (0).

11. FunÃ§Ã£o testMessage
- function testMessage() external { ... }: Esta funÃ§Ã£o pÃºblica demonstra como enviar uma mensagem CCIP para cunhar um NFT na rede Sepolia.
    - Ela codifica uma chamada Ã  funÃ§Ã£o mintFrom do contrato de cunhagem de NFT, passando o endereÃ§o do remetente e o ID da rede Sepolia.
    - Em seguida, ela tenta executar essa mensagem como uma chamada de funÃ§Ã£o no contrato de cunhagem de NFT.
    - Se a chamada for bem-sucedida, o evento MintCallSuccessfull Ã© emitido.

12. FunÃ§Ã£o updateNFT
- function updateNFT(address nftAddress) external { ... }: Esta funÃ§Ã£o pÃºblica permite atualizar o endereÃ§o do contrato de cunhagem de NFT.
    - Ela atribui o novo endereÃ§o Ã  variÃ¡vel nft.

-------------------------------------------------------------------------------
Deploy
Parametro - EndereÃ§o do NFT

Nome - CrossDestinationMinter address
Sol - 0x33982428Be21eC88C45f48B7BEDE39bD5361E4D7
Pedr0x - 0x3640a0Cd803a2EcEC65f6E52EA3aC0D1eDc0D00e
Jeff Souza - 0xb1C8D12957fdc4219Bb732fd9dF30EA88f97ED5F
Marina - 0x054dD983Ad380B8A706Bf544cB07a4aD1e459e28
Raphael - 0x8147b60CF0424159bc099d53bEeAC3F314A171Cb
Alexandre Eduardo - 0x59e595849D90c854638860ff93fC2099780ce491
JosÃ© Aldo - 0xB1A040A19ae367BDDF506Cdc34CcEca32cDdd551

***********************

testMint
testMessage


Origem
Avalanche Fuji

Destino
Ethereum Sepolia

Addicionar Fuji no Metamask
https://chainlist.org/chain/43113

Connect wallet
Avalanche Fuji Testnet - Add to Metamask

Add LINK on Fuji on Metamask
https://docs.chain.link/resources/link-token-contracts#fuji-testnet

https://faucets.chain.link/fuji
LINK e Avax Fuji

Nao conseguiu? Tenta aqui
Somente no workshop
https://workshop-faucet.vercel.app/faucets
BigMac777


consegui 2 AVAX no faucet: https://core.app/tools/testnet-faucet/?subnet=c&token=c nÃ£o precisou de GitHub

Ah! eu vi que tinha o cupom opcional mas como funcionou sem eu nem li que tinha de ter na mainnet

No Remix
Icone 5 - DEPLOY & RUN TRANSACTIONS
ENVIRONMENT
Verifica a rede conectada
Tem que ser
Custom (43113) network

No Remix
Icon2 2 - FILE EXPLORER
Criar
CrossSourceMinter.sol

******************************* InÃ­cio do cÃ³digo *******************************
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// Deploy this contract on Fuji

import {IRouterClient} from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";
import {Client} from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */
contract CrossSourceMinter {

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance to cover the fees.
    error NothingToWithdraw(); // Used when trying to withdraw but there's nothing to withdraw.

    IRouterClient public router;
    LinkTokenInterface public linkToken;
    uint64 public destinationChainSelector;
    address public owner;
    address public destinationMinter;

    event MessageSent(bytes32 messageId);

    constructor(address destMinterAddress) {
        owner = msg.sender;

        // https://docs.chain.link/ccip/supported-networks/testnet

        // from Fuji
        address routerAddressFuji = 0xF694E193200268f9a4868e4Aa017A0118C9a8177;
        router = IRouterClient(routerAddressFuji);
        linkToken = LinkTokenInterface(0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846);
        linkToken.approve(routerAddressFuji, type(uint256).max);

        // to Sepolia
        destinationChainSelector = 16015286601757825753;
        destinationMinter = destMinterAddress;
    }

    function mintOnSepolia() external {
        // Mint from Fuji network = chain[1]
        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
            receiver: abi.encode(destinationMinter),
            data: abi.encodeWithSignature("mintFrom(address,uint256)", msg.sender, 1),
            tokenAmounts: new Client.EVMTokenAmount[](0),
            extraArgs: Client._argsToBytes(
                Client.EVMExtraArgsV1({gasLimit: 980_000})
            ),
            feeToken: address(linkToken)
        });        

        // Get the fee required to send the message
        uint256 fees = router.getFee(destinationChainSelector, message);

        if (fees > linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(linkToken.balanceOf(address(this)), fees);

        bytes32 messageId;
        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend(destinationChainSelector, message);
        emit MessageSent(messageId);
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function linkBalance (address account) public view returns (uint256) {
        return linkToken.balanceOf(account);
    }

    function withdrawLINK(
        address beneficiary
    ) public onlyOwner {
        uint256 amount = linkToken.balanceOf(address(this));
        if (amount == 0) revert NothingToWithdraw();
        linkToken.transfer(beneficiary, amount);
    }
}
```
***************************** Fim do cÃ³digo *****************************

#### Explicando o contrato CrossChainPriceNFT.sol

1. LicenÃ§a e Pragma
- // SPDX-License-Identifier: MIT: Define a licenÃ§a MIT usada pelo contrato.
- pragma solidity 0.8.19;: Especifica a versÃ£o Solidity utilizada para compilar o contrato (versÃ£o 0.8.19).

2. ImportaÃ§Ãµes
- import {IRouterClient} from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";: Importa a interface IRouterClient da biblioteca Chainlink CCIP para interagir com o roteador CCIP.
- import {Client} from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";: Importa a biblioteca Client da Chainlink CCIP para auxiliar na construÃ§Ã£o e envio de mensagens CCIP.
- import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol";: Importa a interface LinkTokenInterface para interagir com o contrato do token LINK da Chainlink.

3. Contrato CrossSourceMinter
- contract CrossSourceMinter { ... }: Define o contrato CrossSourceMinter responsÃ¡vel por enviar mensagens de cunhagem de NFT para outra blockchain.

4. DefiniÃ§Ã£o de Erros Personalizados
- Define dois erros personalizados para fornecer mensagens de reversÃ£o mais informativas:
    - NotEnoughBalance: Indica que o contrato nÃ£o tem saldo suficiente para cobrir as taxas de envio da mensagem.
    - NothingToWithdraw: Indica que nÃ£o hÃ¡ saldo de LINK para ser retirado. 

5. VariÃ¡veis de Estado
- IRouterClient public router;: Armazena o endereÃ§o do roteador CCIP com o qual o contrato se comunica.
LinkTokenInterface public linkToken;: Armazena o endereÃ§o do contrato do token LINK da Chainlink.
uint64 public destinationChainSelector;: Armazena o identificador da blockchain destino (Sepolia neste caso).
- address public owner;: Armazena o endereÃ§o do proprietÃ¡rio do contrato.
- address public destinationMinter;: Armazena o endereÃ§o do contrato de cunhagem de NFT na blockchain destino.

6. Evento MessageSent
- Define um evento para registrar o envio de uma mensagem CCIP e seu identificador.

7. Construtor (constructor)
- constructor(address destMinterAddress) { ... }: O construtor recebe o endereÃ§o do contrato de cunhagem de NFT na blockchain destino como argumento e:
    - Define o endereÃ§o do proprietÃ¡rio do contrato como o remetente da transaÃ§Ã£o (msg.sender).
    - Carrega os endereÃ§os do roteador CCIP e do contrato LINK na rede Fuji a partir de valores codificados (nÃ£o use em produÃ§Ã£o).
    - Aprova o gasto ilimitado de LINK para o roteador CCIP (somente para fins de demonstraÃ§Ã£o).
    - Define o identificador da blockchain destino (Sepolia).
    - Define o endereÃ§o do contrato de cunhagem de NFT na blockchain destino. 

8. FunÃ§Ã£o mintOnSepolia
- function mintOnSepolia() external { ... }: Esta funÃ§Ã£o pÃºblica permite solicitar a cunhagem de um NFT na blockchain destino (Sepolia).
    - ConstrÃ³i uma mensagem CCIP do tipo EVM2AnyMessage para solicitar a cunhagem:
    - Define o endereÃ§o do contrato de cunhagem de NFT na blockchain destino como receptor da mensagem.
    - Codifica a chamada Ã  funÃ§Ã£o mintFrom do contrato de cunhagem de NFT, passando o endereÃ§o do remetente da transaÃ§Ã£o (msg.sender) e o ID da rede Fuji (1).
    - Define que nÃ£o hÃ¡ tokens para enviar junto com a mensagem.
    - Define os argumentos extras da mensagem, incluindo o limite de gÃ¡s desejado (980_000).
    - Define o token LINK como token de pagamento das taxas.
- ObtÃ©m a taxa necessÃ¡ria para enviar a mensagem usando router.getFee.
- Verifica se o contrato possui saldo suficiente de LINK para pagar as taxas.
- Envia a mensagem CCIP usando router.ccipSend e armazena o identificador da mensagem.
- Emite o evento MessageSent para indicar que a mensagem foi enviada com sucesso.

9. Modificador onlyOwner
- modifier onlyOwner() { ... }: Este modificador restringe a execuÃ§Ã£o de uma funÃ§Ã£o ao proprietÃ¡rio do contrato. 

10. FunÃ§Ã£o linkBalance
- function linkBalance (address account) public view returns (uint256) { ... }: Esta funÃ§Ã£o pÃºblica retorna o saldo de LINK de um determinado endereÃ§o.

11. FunÃ§Ã£o withdrawLINK
- function withdrawLINK(address beneficiary) public onlyOwner { ... }: Esta funÃ§Ã£o pÃºblica permite que o proprietÃ¡rio do contrato retire o saldo de LINK do contrato para um endereÃ§o especificado.
    - Verifica se hÃ¡ saldo de LINK para retirar.
    - Transfere o saldo de LINK para o endereÃ§o do beneficiÃ¡rio.

---------------------------------------------------------------------------------------
Deploy
Parametro: CrossDestinationMinter address
(contrato que voce publicou antes, na Sepolia)

Nome - CrossSourceMinter address
Sol - 0x08dFEBD8f2868cb724A578f8368F62678489d4Af
Pedr0x - 0x6e5FB12622F1B897ae14e702A88174C6aBd51676
Marina - 0x58D21d4ce5cc1F0A53c8751e46AAcDA841944509
Raphael - 0x72f541e792575EA506E3f698112CDA4d41df26Fa
Jeff Souza - 0x74B6C42ed5859A8d73A0D641090273841A276D06
JosÃ© Aldo - 0xB1A040A19ae367BDDF506Cdc34CcEca32cDdd551
Alexandre Eduardo - 0x47b423a3a0EAD547f2f3312fCFE6307666cC64AA


Add LINK na Fuji - Metamask
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846

No Metamask
Enviar 5 LINK para o endenreco do CrossSourceMinter 

No Remix
Executar
MintOnSepolia

No Metamask - copy transaction id
Nome - TX Id
Sol - 0x3f1f977382549bbf795941bb67e479a4090af18138196759f96ad64b17288be2
Raphael - 0xa83ddbfa9517e5012ebb5eac8e3ebc1ee1b5784e9b45850de3d36d996b72a712
Marina -
0xc17099b7ec1562070c35b0eeedbede3966313c87beb2cb7fe4963cebe7862ce5
0x013397aeedff03a240bf827914828855afb53c4d2159489d99d396d2d6dd6136
Jeff Souza - 0x279c7f7d072dac29e6759964c8c8965348111aee63bbeb541ce2009c392dbb03
Sol2 - 0x0d5fe63d8e495550415546104db3fd4d826d6fb4032c47bb903e6e6afe847e33
Alexandre Eduardo - 0x56d0a8b53c239783d9f55cb933f9c0620beb21c2e5bc15b7f45e945e7adc2679
Pedr0x - 0x6e2a9099c5f131586f2b400523e4cbe22db4180a623f1542095c5c238471ca2d
JosÃ© Aldo - 0x33c2ce8abc6ea6da9a3986ced48bd3e8cceda277ceaa06e277591bab613ce712
*******************************************

https://ccip.chain.link/
Pesquisar o hash da transacao